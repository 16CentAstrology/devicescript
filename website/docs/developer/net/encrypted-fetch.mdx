---
title: Encrypted Fetch
sidebar_position: 14.5
---

# Encrypted Fetch

The `@devicescript/net` package contains `encryptedFetch()` function which lets you
HTTP POST encrypted data and read encrypted responses.
The encryption uses `aes-256-ccm`.

Let's see how this works!

First, set up a `main.ts` file:

```ts
import { assert } from "@devicescript/core"
import { sha256Hkdf } from "@devicescript/crypto"
import { URL, encryptedFetch } from "@devicescript/net"
import { readSetting } from "@devicescript/settings"

async function sendReq(data: any) {
    const url = new URL(await readSetting<string>("ENC_HTTP_URL"))
    const pass = url.hash.split("pass=")[1]
    assert(pass !== "SecretPassword", "Please change password in production!")
    const key = sha256Hkdf(pass, "")
    url.hash = ""
    return await encryptedFetch({
        data,
        key,
        url,
    })
}
console.log(
    await sendReq({
        hello: "world",
    })
)
```

Second, create a file with secrets.
Make sure, `ENC_HTTP_KEY` is 64 hex characters long (for 32 byte/256 bit key).
Use the widget below if you need a demo key.

```env title="./.env.local"
# Local settings and secrets
# This file should **NOT** tracked by git
# Make sure to put the value below in "..."; otherwise the # gets treated as comment
ENC_HTTP_URL="http://localhost:8080/api/devs-enc-fetch/mydevice#pass=SecretPassword"
```

In production, you may want to use `deviceIdentifier('self')` as the user name,
provided you handle that server-side.


On the server side, you can run the code below.
Feel free to adopt to other languages or frameworks.

:::warning

Two devices should never share a key.

:::

```ts skip
import express from "express"
import bodyParser from "body-parser"
import * as crypto from "node:crypto"
import { config } from "dotenv"

function getKeyForDevice(deviceId: string): Buffer | undefined {
    // TODO look up device in database here!

    config({ path: "./.env.local" })
    const url = new URL(process.env["ENC_HTTP_URL"] + "")
    if (url.pathname.replace(/.*\//, "") == deviceId) {
        const pass = url.hash.split("pass=")[1]
        if (pass !== "SecretPassword")
            return Buffer.from(crypto.hkdfSync("sha256", pass, "", "", 32))
    }

    return undefined
}

const TAG_BYTES = 4
const IV_BYTES = 13
const KEY_BYTES = 32

function aesCcmEncrypt(key: Buffer, iv: Buffer, plaintext: Buffer) {
    if (key.length != KEY_BYTES || iv.length != IV_BYTES)
        throw new Error("Invalid key/iv")

    const cipher = crypto.createCipheriv("aes-256-ccm", key, iv, {
        authTagLength: TAG_BYTES,
    })
    const b0 = cipher.update(plaintext)
    const b1 = cipher.final()
    const tag = cipher.getAuthTag()
    return Buffer.concat([b0, b1, tag])
}

function aesCcmDecrypt(key: Buffer, iv: Buffer, msg: Buffer) {
    if (
        key.length != KEY_BYTES ||
        iv.length != IV_BYTES ||
        !Buffer.isBuffer(msg)
    )
        throw new Error("invalid key, iv or msg")

    if (msg.length < TAG_BYTES) return null

    const decipher = crypto.createDecipheriv("aes-256-ccm", key, iv, {
        authTagLength: TAG_BYTES,
    })

    decipher.setAuthTag(msg.slice(msg.length - TAG_BYTES))

    const b0 = decipher.update(msg.slice(0, msg.length - TAG_BYTES))
    try {
        decipher.final()
        return b0
    } catch {
        return null
    }
}

const app = express()
app.post(
    "/api/devs-enc-fetch/:deviceId",
    bodyParser.raw({ type: "application/x-devs-enc-fetch" }),
    (req, res) => {
        const { deviceId } = req.params
        const key = getKeyForDevice(deviceId)
        if (!key) {
            console.log(`No device ${deviceId}`)
            res.sendStatus(404)
            return
        }

        console.log(`Device connected ${deviceId}`)

        const reqIV = Buffer.from(
            req.headers["x-devs-enc-fetch-iv"] + "",
            "hex"
        )
        const body = aesCcmDecrypt(key, reqIV, req.body as Buffer)
        if (!body) {
            console.log(`Can't decrypt`)
            res.sendStatus(400)
            return
        }
        const obj = JSON.parse(body.toString("utf-8"))
        console.log("Request body:", obj)

        const rid = obj.$rid
        const respIV = Buffer.from(obj.$iv, "hex")

        // TODO check for duplicate rid!

        const resp = {
            $rid: rid,
            response: "Got it!",
        }

        const rbody = aesCcmEncrypt(
            key,
            respIV,
            Buffer.from(JSON.stringify(resp), "utf8")
        )
        res.end(rbody)
    }
)

app.listen(8080)
```

## Technical description

The `encryptedFetch()` function performs as HTTP request which uses `content-type` of `application/x-devs-enc-fetch`
and two special headers.
The `x-devs-enc-fetch-info` header contains information about the request encryption algorithm
and can be safely ignored.
The `x-devs-enc-fetch-iv` header contain hex-encoded 13-byte initialization vector (or nonce) for the AES-256-CCM
encryption method.

The `encryptedFetch()` function also requires a key, which is a 32-byte buffer.
In the examples above, the key is derived from password using HMAC key derivation function (HKDF) from RFC 5869.
This key is used for both encryption and authentication of the request.

The body of the request is a JSON object.
Before sending it out, `encryptedFetch()` extends it with response initialization vector
(which is hex-encoded and stored in `$iv` property)
and a random request identifier (stored in `$rid` property).
After these extensions, the JSON object is converted to a buffer and
encrypted using AES-256-CCM and a 4-byte authentication tag is appended.

This is send to the server, which decrypts the request accordingly.

:::warning

If applicable, the server should check if a request with a given `$rid` was already handled,
and if so, reject it.
Otherwise, someone can reply a client request.

:::

If the server responds with with `2xx` code, the response is assumed to be
a JSON object encrypted using the same key and the `$iv` from the request.
The response also has the 4-byte authentication tag.

If the response is not `2xx` or if it cannot be authenticated an exception is thrown.
Otherwise, the JSON object of the response is returned.
